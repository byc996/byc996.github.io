(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{497:function(t,v,_){"use strict";_.r(v);var a=_(41),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"封装encapsulation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#封装encapsulation"}},[t._v("#")]),t._v(" 封装 Encapsulation")]),t._v(" "),_("p",[t._v("将数据和和操作数据的方法绑定到同一个单元内（类）。通常会定义所有的成员变量为 "),_("code",[t._v("private")]),t._v(" ，避免外部直接访问，通过 "),_("code",[t._v("public")]),t._v("  方法进行访问。这样就可以控制数据的访问权限。")]),t._v(" "),_("h2",{attrs:{id:"继承inheritance"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承inheritance"}},[t._v("#")]),t._v(" 继承 Inheritance")]),t._v(" "),_("ul",[_("li",[t._v("子类拥有父类所有的属性和方法，但是 "),_("code",[t._v("private")]),t._v("  的属性和方法无法访问。")]),t._v(" "),_("li",[_("code",[t._v("final")]),t._v("  关键字修饰的类无法继承")]),t._v(" "),_("li",[_("code",[t._v("super")]),t._v("  关键字可以调用父类的 "),_("code",[t._v("public")]),t._v("  方法和属性（包括构造函数），this 关键字可以调用当前对象的属性和方法")]),t._v(" "),_("li",[t._v("Java 中类不支持多继承，接口可以多继承")])]),t._v(" "),_("div",{staticClass:"custom-block note"},[_("p",{staticClass:"custom-block-title"},[t._v("笔记")]),t._v(" "),_("p",[t._v("Java 中创建子类对象不会创建父类对象！"),_("a",{attrs:{href:"https://juejin.cn/post/6844903667833765902",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),_("OutboundLink")],1)]),t._v(" "),_("ul",[_("li",[t._v("创建对象指的是在堆区开辟空间")]),t._v(" "),_("li",[t._v("编译器在运行子类构造器之前，必须先执行父类构造器；且调用父类构造器的语句必须在子类构造器的第一行。")]),t._v(" "),_("li",[t._v("构造方法的作用是为堆区中的对象的属性初始化，不是创建对象。")])])]),t._v(" "),_("h2",{attrs:{id:"多态polymorphism"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态polymorphism"}},[t._v("#")]),t._v(" 多态 Polymorphism")]),t._v(" "),_("p",[t._v("什么是多态？"),_("strong",[t._v("同一")]),t._v("个行为具有"),_("strong",[t._v("多个")]),t._v("不同表现形式或形态的能力。")]),t._v(" "),_("h3",{attrs:{id:"多态的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态的分类"}},[t._v("#")]),t._v(" 多态的分类")]),t._v(" "),_("p",[t._v("多态分为"),_("strong",[t._v("编译时多态（静态）"),_("strong",[t._v("和")]),t._v("运行时多态（动态）")]),t._v("。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/byc996/picb/20230425172313.png",alt:"image-20230425172313423"}})]),t._v(" "),_("h3",{attrs:{id:"多态的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态的特点"}},[t._v("#")]),t._v(" "),_("strong",[t._v("多态的特点")])]),t._v(" "),_("p",[t._v("父类引用变量指向子类对象")]),t._v(" "),_("p",[t._v("引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；")]),t._v(" "),_("p",[t._v("多态不能调用 “只在子类存在但在父类不存在” 的方法；")]),t._v(" "),_("p",[t._v("如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。")]),t._v(" "),_("h2",{attrs:{id:"抽象abstraction"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象abstraction"}},[t._v("#")]),t._v(" 抽象 Abstraction")]),t._v(" "),_("p",[t._v("Java 中主要通过"),_("strong",[t._v("抽象类")]),t._v("和"),_("strong",[t._v("接口")]),t._v("来实现抽象的。")]),t._v(" "),_("h3",{attrs:{id:"抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),_("ul",[_("li",[t._v("抽象方法不能为 "),_("code",[t._v("private")]),t._v(" ，必须使用 "),_("code",[t._v("abstract")]),t._v("  修饰")]),t._v(" "),_("li",[t._v("不能有实现体，必须被子类重写")])]),t._v(" "),_("h3",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),_("ul",[_("li",[t._v("类能实现多个接口，接口可以继承多个接口")]),t._v(" "),_("li",[t._v("接口不能为静态，但能有静态方法（必须有具体实现）")]),t._v(" "),_("li",[t._v("实现类对象无法调用接口的静态方法，但子类对象能调用父类的非私有静态方法（但建议使用类。方法的形式调用）")]),t._v(" "),_("li",[t._v("接口实现了松耦合，类之间互相不影响")])]),t._v(" "),_("h3",{attrs:{id:"接口-vs-抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口-vs-抽象类"}},[t._v("#")]),t._v(" 接口 VS 抽象类")]),t._v(" "),_("p",[t._v("相同点：")]),t._v(" "),_("ul",[_("li",[t._v("都不能被实例化")]),t._v(" "),_("li",[t._v("都可以可以包括抽象方法（接口中加不加 "),_("code",[t._v("abstract")]),t._v("  关键字都一样）")]),t._v(" "),_("li",[t._v("都可以有默认方法（接口在 Java 8 之后支持默认方法，使用 "),_("code",[t._v("default")]),t._v("  关键字）")])]),t._v(" "),_("p",[t._v("不同点：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[_("strong",[t._v("接口")])]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[_("strong",[t._v("抽象类")])])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("支持多继承")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("不支持多继承")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("所有成员都是公共的 "),_("code",[t._v("public")])]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("成员可以是 "),_("code",[t._v("private")]),t._v(" ,  "),_("code",[t._v("protected")]),t._v("  , "),_("code",[t._v("public")])])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("成员变量必须是 "),_("code",[t._v("static")]),t._v("  and  "),_("code",[t._v("final")])]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("成员变量可以是静态或非静态")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("不能有构造函数")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("可以定义构造函数")])])])]),t._v(" "),_("h3",{attrs:{id:"函数式接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数式接口"}},[t._v("#")]),t._v(" 函数式接口")]),t._v(" "),_("p",[t._v("函数式接口：只有"),_("strong",[t._v("一个")]),t._v("抽象方法。（可以有多个默认方法）")]),t._v(" "),_("p",[_("code",[t._v("@FunctionalInterface")]),t._v("  注解不是必须的，但是如果加了注解而且有多个抽象方法，则会报错。")]),t._v(" "),_("p",[t._v("Java 8 中定义了 "),_("code",[t._v("java.util.function")]),t._v("  包，包含一些函数式接口，比如 "),_("code",[t._v("Predicate")]),t._v(" ,  "),_("code",[t._v("Consumer")]),t._v(" ,  "),_("code",[t._v("Supplier")]),t._v(" ,  "),_("code",[t._v("Function")]),t._v(" , 等等")])])}),[],!1,null,null,null);v.default=e.exports}}]);