(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{503:function(e,t,n){"use strict";n.r(t);var r=n(41),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("参考："),n("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1954074",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 开发者必须掌握的 20 个 Spring 常用注解"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"_1-声明bean的注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-声明bean的注解"}},[e._v("#")]),e._v(" 1. 声明 bean 的注解")]),e._v(" "),n("ul",[n("li",[e._v("@Component：泛指组件")]),e._v(" "),n("li",[e._v("@Controller：控制层组件")]),e._v(" "),n("li",[e._v("@Service：业务层（business logic）组件")]),e._v(" "),n("li",[e._v("@Repository：数组访问层组件")])]),e._v(" "),n("blockquote",[n("p",[e._v("@Controller、@Service、@Repository 本质上并无区别，只是用于标记不同类型的组件。")]),e._v(" "),n("p",[e._v("@Component 可以用来标记其他组件。")])]),e._v(" "),n("h3",{attrs:{id:"spring-bean默认名称规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean默认名称规则"}},[e._v("#")]),e._v(" Spring bean 默认名称规则")]),e._v(" "),n("ul",[n("li",[e._v("如果 @Component、@Controller、@Service、@Repository、@Bean 在创建 bean 时制定了 bean 的名称，则为指定的名称。")]),e._v(" "),n("li",[e._v("如果不指定 bean 的名称，bean 名称的默认规则是类名的首字母小写，其余不变， 比如 UserMapper- > userMapper")]),e._v(" "),n("li",[e._v("如果类名前两个或者两个以上字符都是大写，则 bean 的名称不变，与类名一样。")])]),e._v(" "),n("h3",{attrs:{id:"为什么-service-在实现类上而不是接口上"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么-service-在实现类上而不是接口上"}},[e._v("#")]),e._v(" 为什么 @Service 在实现类上而不是接口上？")]),e._v(" "),n("p",[e._v("@Service 注解是标注在实现类上的，因为 @Service 是把 spring 容器中的 bean 进行实例化，也就是等同于 new 操作，只有实现类是可以进行 new 实例化的，而接口则不能，所以是加在实现类上的。")]),e._v(" "),n("h2",{attrs:{id:"_2-注入bean的注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-注入bean的注解"}},[e._v("#")]),e._v(" 2. 注入 bean 的注解")]),e._v(" "),n("ul",[n("li",[e._v("@Autowired：spring 定义的注解，默认是根据类型 byType 自动注入被 Spring 管理的对象到类中")]),e._v(" "),n("li",[e._v("@Resource：JDK 原生的注解，默认根据名称 byName 自动注入对象")]),e._v(" "),n("li",[e._v("@Inject：JDK 原生的注解，默认也是按照类型（byType）装配依赖对象，使用需要添加 "),n("code",[e._v("javax.inject")]),e._v("  依赖")]),e._v(" "),n("li",[e._v("@Value：属性注入值（作用在属性上），可以是常量，系统变量，表达式，配置文件等等")])]),e._v(" "),n("h3",{attrs:{id:"autowired-和-resource-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#autowired-和-resource-的区别"}},[e._v("#")]),e._v(" @Autowired 和 @Resource 的区别")]),e._v(" "),n("p",[e._v("@Resource 和 @Autowired 都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。")]),e._v(" "),n("p",[n("strong",[e._v("不同点")]),e._v("：")]),e._v(" "),n("ol",[n("li",[e._v("@Resource 是 JDK 原生的注解，@Autowired 是 Spring2.5 引入的注解")]),e._v(" "),n("li",[e._v("@Autowired 默认按 byType 自动装配，而 @Resource 默认 byName 自动装配。@Resource 有两个属性 name 和 type。\n"),n("ul",[n("li",[e._v("Spring 将 @Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不指定 name 也不指定 type 属性，这时将通过反射机制使用 byName 自动注入策略。")])])]),e._v(" "),n("li",[e._v("@Autowired 能够用在：构造器、方法、参数、成员变量和注解上，而 @Resource 能用在：类、成员变量和方法上")]),e._v(" "),n("li",[e._v("@Autowired 如果要使用 byName，需要使用 @Qualifier 一起配合。而 @Resource 如果指定了 name，则用 byName 自动装配，如果指定了 type，则用 byType 自动装配。")])]),e._v(" "),n("p",[e._v("参考："),n("a",{attrs:{href:"https://juejin.cn/post/7022507865701089317",target:"_blank",rel:"noopener noreferrer"}},[e._v("@Autowired 和 @Resource 的区别"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"_3-java配置类相关注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-java配置类相关注解"}},[e._v("#")]),e._v(" 3. Java 配置类相关注解")]),e._v(" "),n("ul",[n("li",[e._v("@Configuration：声明当前类为配置类，其中内部组合了 @Component 注解，表明这个类是一个 bean, 所以也可以使用 @Component 注解替代。")]),e._v(" "),n("li",[e._v("@Bean：注解在方法上，声明当前方法的返回值为一个 bean。")]),e._v(" "),n("li",[e._v("@ComponentScan：扫描被 @Component 注解的 bean，默认扫描路径为当前类所在包下的所有类。")])]),e._v(" "),n("h2",{attrs:{id:"_4-apo切面相关注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-apo切面相关注解"}},[e._v("#")]),e._v(" 4. APO 切面相关注解")]),e._v(" "),n("ul",[n("li",[e._v("@Aspect：将一个 java 类定义为切面类（类上）")]),e._v(" "),n("li",[e._v("@Before：在切入点开始处切入内容，在方法执行之前执行（方法上）")]),e._v(" "),n("li",[e._v("@After：在切入点结尾处切入内容，在方法执行之后执行（方法上）")]),e._v(" "),n("li",[e._v("@Around：在切入点前后切入内容， 在方法执行之前与之后执行（方法上）")]),e._v(" "),n("li",[e._v("@PointCut：定义一个切入点，可以是一个规则表达式，比如下例中某个 package 下的所有函数，也可以是一个注解等。")])]),e._v(" "),n("h2",{attrs:{id:"_5-bean的属性支持"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-bean的属性支持"}},[e._v("#")]),e._v(" 5. Bean 的属性支持")]),e._v(" "),n("ul",[n("li",[e._v("@Scope：设置 Spring 容器如何新建 Bean 实例（与 @Component 或 @Bean 一起使用）\n"),n("ul",[n("li",[e._v("Singleton：单例，一个 Spring 容器中只有一个 bean 实例，默认模式")]),e._v(" "),n("li",[e._v("Protetype：每次调用新建一个 bean")]),e._v(" "),n("li",[e._v("Request：web 项目中，给每个 http request 新建一个 bean")]),e._v(" "),n("li",[e._v("Session， GlobalSession， …")])])]),e._v(" "),n("li",[e._v("@PostConstruct：在构造函数执行完之后执行 (@Target 为方法)，, 一般用来执行某些初始化操作")]),e._v(" "),n("li",[e._v("@PreDestory：在 Bean 销毁之前执行 (@Target 为方法)，一般用来释放 bean 所持有的资源")])]),e._v(" "),n("h2",{attrs:{id:"_6-环境切换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-环境切换"}},[e._v("#")]),e._v(" 6. 环境切换")]),e._v(" "),n("ul",[n("li",[e._v("@Profile：指定类或方法在特定的 Profile 环境生效，任何 @Component 或 @Configuration 注解的类都可以使用 @Profile 注解。")]),e._v(" "),n("li",[e._v("@Conditional：通过实现 Condition 接口，并重写 matches 方法，按照一定条件进行判断，满足条件就将 bean 注册到容器。@Conditional 标注在类上就决定了一批 bean 是否注入。")])]),e._v(" "),n("h2",{attrs:{id:"_7-异步相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-异步相关"}},[e._v("#")]),e._v(" 7. 异步相关")]),e._v(" "),n("ul",[n("li",[e._v("@EnableAsync：配置类中，通过此注解开启对异步任务的支持")]),e._v(" "),n("li",[e._v("@Async：在实际执行的 bean 方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要 @EnableAsync 开启异步任务）")])]),e._v(" "),n("h2",{attrs:{id:"_8-定时任务相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-定时任务相关"}},[e._v("#")]),e._v(" 8. 定时任务相关")]),e._v(" "),n("ul",[n("li",[e._v("@EnableScheduling：开启定时任务的支持（类上）")]),e._v(" "),n("li",[e._v("@Scheduled：申明这是一个任务，包括 cron,fixDelay,fixRate 等类型（方法上，需先开启计划任务的支持）")])]),e._v(" "),n("blockquote",[n("p",[e._v("@Enable 注解主要用来开启对 xx 的支持，比如 EnableScheduling 开启对定时任务的支持。")])]),e._v(" "),n("h2",{attrs:{id:"_9-springmvc-注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-springmvc-注解"}},[e._v("#")]),e._v(" 9. SpringMVC 注解")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("@EnableWebMvc：在配置类中开启 Web MVC 的配置支持")])]),e._v(" "),n("li",[n("p",[e._v("@RequestMapping：用于映射 Web 请求，包括访问路径和参数（类或方法上）")])]),e._v(" "),n("li",[n("p",[e._v("@GetMapping：用于处理 HTTP GET 请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping 是一个组合注解，它相当于是 @RequestMapping (method=RequestMethod.GET) 的快捷方式。")])]),e._v(" "),n("li",[n("p",[e._v("@PostMapping：用于处理 HTTP POST 请求，并将请求映射到具体的处理方法中。@PostMapping 与 @GetMapping 一样，也是一个组合注解，它相当于是 @RequestMapping (method=HttpMethod.POST) 的快捷方式。")])]),e._v(" "),n("li",[n("p",[e._v("@ResponseBody：支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据（返回值旁或方法上）。@RequestBody 允许 request 的参数在 request 体中，而不是在直接连接在地址后面。（放在参数前）")])]),e._v(" "),n("li",[n("p",[e._v('@RequestParam：用于接收 URL 中的参数信息。 比如：@RequestParam ("name") String name')]),e._v(" "),n("ul",[n("li",[e._v("@RequestParam 和 @ResponseBody 的区别：\n"),n("ul",[n("li",[e._v("@RequestParam 接收 URL 中的参数，而 @ResponseBody 是接收 request 请求体中的数据")]),e._v(" "),n("li",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/byc996/picb/image-20230515210527142.png",alt:"image-20230515210527142"}})])])])])]),e._v(" "),n("li",[n("p",[e._v("@PathVariable：用于接收 URL 中的参数信息，不过和 @RequestParam 注解稍有不同。@PathVariable 注解用于解析 Url 中的路径参数（/user/{name})， @RequestParam 注解用于解析 Url 中的查询参数 (user?name=xxx)")])]),e._v(" "),n("li",[n("p",[e._v("@RestController：该注解为一个组合注解，相当于 @Controller 和 @ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了 @ResponseBody")])]),e._v(" "),n("li",[n("p",[e._v("@RestControllerAdvice：")])]),e._v(" "),n("li",[n("p",[e._v("是一个组合注解，由 @ControllerAdvice、@ResponseBody 组成，而 @ControllerAdvice 继承了 @Component，因此 @RestControllerAdvice 本质上是个 Component，用于定义 @ExceptionHandler，@InitBinder 和 @ModelAttribute 方法，适用于所有使用 @RequestMapping 方法。"),n("a",{attrs:{href:"https://blog.csdn.net/user2025/article/details/105458842",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考原文"),n("OutboundLink")],1)]),e._v(" "),n("ul",[n("li",[e._v("通过 @ControllerAdvice 注解可以将对于控制器的全局配置放在同一个位置。")]),e._v(" "),n("li",[e._v("注解了 @RestControllerAdvice 的类的方法可以使用 @ExceptionHandler、@InitBinder、@ModelAttribute 注解到方法上。")]),e._v(" "),n("li",[e._v("@RestControllerAdvice 注解将作用在所有注解了 @RequestMapping 的控制器的方法上。"),n("br"),e._v("\n@ExceptionHandler：用于指定异常处理方法。当与 @RestControllerAdvice 配合使用时，用于全局处理控制器里的异常。"),n("br"),e._v("\n@InitBinder：用来设置 WebDataBinder，用于自动绑定前台请求参数到 Model 中。"),n("br"),e._v("\n@ModelAttribute：本来作用是绑定键值对到 Model 中，当与 @ControllerAdvice 配合使用时，可以让全局的 @RequestMapping 都能获得在此处设置的键值对")])])])]),e._v(" "),n("h2",{attrs:{id:"_10-spring-boot-注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-spring-boot-注解"}},[e._v("#")]),e._v(" 10 Spring Boot 注解")]),e._v(" "),n("p",[e._v("参考："),n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/57689422",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring Boot 最核心的 25 个注解，都是干货！"),n("OutboundLink")],1)]),e._v(" "),n("ul",[n("li",[e._v("@SpringBootApplication：Spring Boot 最核心的注解，用在 Spring Boot 主类上。这个注解就是 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 这三个注解的组合")]),e._v(" "),n("li",[e._v("@EnableAutoConfiguration：允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。比如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。")]),e._v(" "),n("li",[e._v("@Configuration：用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册。")]),e._v(" "),n("li",[e._v("@SpringBootConfiguration：这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展。")]),e._v(" "),n("li",[e._v("@ConfigurationProperties：用来加载额外的配置（如 .properties 文件），可用在 @Configuration 注解类，或者 @Bean 注解方法上面。")]),e._v(" "),n("li",[e._v("@EnableConfigurationProperties：一般要配合 @ConfigurationProperties 注解使用，用来开启对 @ConfigurationProperties 注解配置 Bean 的支持。")]),e._v(" "),n("li",[e._v("@Conditional：用来标识一个 Spring Bean 或者 Configuration 配置文件，当满足指定的条件才开启配置。")]),e._v(" "),n("li",[e._v("@ConditionalOnClass：组合 @Conditional 注解，当容器中有指定的 Class 才开启配置。")]),e._v(" "),n("li",[e._v("@ConditionalOnMissingClass：与 @ConditionalOnClass 相反，当容器中没有指定的 Class 才开启配置。")]),e._v(" "),n("li",[e._v("…")])])])}),[],!1,null,null,null);t.default=a.exports}}]);