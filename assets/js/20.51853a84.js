(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{509:function(a,t,s){"use strict";s.r(t);var e=s(41),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"hashmap结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap结构"}},[a._v("#")]),a._v(" HashMap 结构")]),a._v(" "),s("p",[a._v("HashMap 是一个存储 key-value 键值对的集合，每一个键值对也叫 Entry。")]),a._v(" "),s("p",[a._v("参考："),s("a",{attrs:{href:"https://www.bilibili.com/video/BV1ST411o7GR/?p=4&spm_id_from=pageDriver&vd_source=e000fa398b9a326b467683bfbb9262de",target:"_blank",rel:"noopener noreferrer"}},[a._v("图灵课堂"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/byc996/picb/image-20230424144825198.png",alt:"image-20230424144825198"}})]),a._v(" "),s("h2",{attrs:{id:"hashmap-源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-源码"}},[a._v("#")]),a._v(" HashMap 源码")]),a._v(" "),s("p",[a._v("参考："),s("a",{attrs:{href:"https://www.bilibili.com/video/BV1ST411o7GR/?p=4&spm_id_from=pageDriver&vd_source=e000fa398b9a326b467683bfbb9262de",target:"_blank",rel:"noopener noreferrer"}},[a._v("图灵课堂"),s("OutboundLink")],1)]),a._v(" "),s("h3",{attrs:{id:"核心常量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心常量"}},[a._v("#")]),a._v(" 核心常量")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/byc996/picb/image-20230424151437924.png",alt:"image-20230424151437924"}})]),a._v(" "),s("ul",[s("li",[s("p",[a._v("默认容量： hashmap 数组的大小")])]),a._v(" "),s("li",[s("p",[a._v("负载因子：当数组长度大于 容量 * 负载因子 时， HashMap 会扩容。")]),a._v(" "),s("ul",[s("li",[a._v("加载因子越大，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；")]),a._v(" "),s("li",[a._v("加载因子越小，填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容 rehash 操作的次数。")]),a._v(" "),s("li",[a._v("冲突的机会越大，说明需要查找的数据还需要通过另一个途径查找，这样查找的成本就越高。因此，必须在 “冲突的机会” 与 “空间利用率” 之间，寻找一种平衡与折衷。")])])])]),a._v(" "),s("h3",{attrs:{id:"核心变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心变量"}},[a._v("#")]),a._v(" 核心变量")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/byc996/picb/image-20230424152141081.png",alt:"image-20230424152141081"}})]),a._v(" "),s("h3",{attrs:{id:"构造方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造方法"}},[a._v("#")]),a._v(" 构造方法")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/byc996/picb/image-20230424152303331.png",alt:"image-20230424152303331"}})]),a._v(" "),s("h3",{attrs:{id:"hashmap-put方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-put方法"}},[a._v("#")]),a._v(" HashMap - put 方法")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/byc996/picb/image-20230424153012716.png",alt:"image-20230424153012716"}})]),a._v(" "),s("h2",{attrs:{id:"如何解决hash冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何解决hash冲突"}},[a._v("#")]),a._v(" 如何解决 hash 冲突？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("开放寻址法：又称开放定址法，当哈希冲突发生时，从发生冲突的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。")])]),a._v(" "),s("li",[s("p",[a._v("再哈希法：使用不同的 hash 函数多次 hash 操作，直到不冲突为止。")])]),a._v(" "),s("li",[s("p",[a._v("建立一个公共溢出区：假设哈希函数的值域为 [0, m-1]，设向量 HashTable [0,…,m-1] 为基本表，每个分量存放一个记录，另外还设置了向量 OverTable [0,…,v] 为溢出表。基本表中存储的是关键字的记录，一旦发生冲突，不管他们哈希函数得到的哈希地址是什么，都填入溢出表。")]),a._v(" "),s("p",[a._v("但这个方法的缺点在于：查找冲突数据的时候，需要遍历溢出表才能得到数据。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("拉链法：将冲突位置的元素构造成链表。在添加数据的时候，如果哈希地址与哈希表上的元素冲突，就放在这个位置的链表上。")])])])]),a._v(" "),s("h2",{attrs:{id:"hashmap的扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的扩容机制"}},[a._v("#")]),a._v(" HashMap 的扩容机制")]),a._v(" "),s("p",[a._v("当添加一个元素时，计算出相对于的 hash 值")]),a._v(" "),s("ol",[s("li",[a._v("当 hash 值对应的 value 为空时，直接作为一个 node 赋值到 value")]),a._v(" "),s("li",[a._v("当 value 为 linkedlist 时，将元素添加到 list 的尾部。如果 list 的长度大于 8 并且散列表的长度小于 64 时，会先进行扩容再重新 hash；如果 list 的长度大于 8 并且散列表的长度大于 64 时，链表会转换成红黑树")]),a._v(" "),s("li",[a._v("当 value 是红黑树节点时，将元素插入树中并调整数的结构。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);